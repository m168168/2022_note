## 剑指offer

###  1：二维数组的查找

在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 

```
[[1,2,8,9], [2,4,9,12],[4,7,10,13],[6,8,11,15]]
给定 target = 7，返回 true。 
# -*- coding:utf-8 -*-
class Solution:
    # array 二维列表
    def Find(self, target, array):
        # write code here
        m = len(array)
        n = len(array[0])-1
         
        if m == 0 or m==0:
            return False
        row = 0
        while row < m and n >=0:
            if target == array[row][n]:
                return True
            if array[row][n]>target:
                n = n-1
                continue
            if array[row][n]<target:
                row +=1
                continue
        return False
       
```

### 2: 空格替换

请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

```
#include <iostream>
using namespace std;
class Solution {
public:
    string replaceSpace(string s) {
        // write code here
        string str = "%20" ;
        string res = "" ;
        for(int i = 0 ;i< s.size() ;i++){
             res +=(s[i]== ' ')? str:string(1,s[i]) ;
        }
        return res ;  
    }
};
```

### 3：从尾到头打印链表

输入一个链表，按链表从尾到头的顺序返回一个ArrayList。

```
vector<int> printListFromTailToHead(ListNode* head) {
    vector<int> ret;
    while (head) {
        ret.push_back(head->val);
        head = head->next;
    }       
    std::reverse(ret.begin(), ret.end());
    return ret;
}
反转链表
vector<int> printListFromTailToHead(ListNode* head) {
    ListNode* pre = nullptr;
    ListNode* cur = head;
    ListNode temp = cur;
    while (cur) {
        temp = cur->next; //需要现保存一下，不然断开了就找不到了
        cur->next = pre;
        pre = cur; // pre 和 cur分别向右边平移
        cur = temp;
    }
    vector<int> ret;
    while (pre) {
        ret.push_back(pre->val);
        pre = pre->next;
    }
    return ret;
}
```

### 4：重建二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

```
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    unordered_map<int , int > pos ;
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
//         int n = pre.size() ;
//         if(n == 0)
//             return NULL ;
//         vector<int>  pl ,pr ,vl ,vr ;
//         int  gen = 0  ;  //root 节点   ，分成左右两边 ， 添加到 pl rl, pr,vr
        
//         TreeNode *root = new TreeNode(pre[0]) ;
//         for(  ; gen< n ;gen++){
//             if(vin[gen] == pre[0]){
//                 break ;
//             }
//         }
//         for(int i = 0 ; i< gen ;i++){
//             vl.push_back(vin[i]) ;
//             pl.push_back(pre[i+1]) ;
//         }
//         for(int j = gen+1 ;j< n ;j++){
//             vr.push_back(vin[j]) ;
//             pr.push_back(pre[j]) ;
//         }
//         // 继续递归 
//         root->left = reConstructBinaryTree(pl ,vl) ;
//         root->right = reConstructBinaryTree(pr, vr) ;
//         return root ;
        int n = pre.size() ;
        for(int i = 0 ;i< n ;i ++){
            pos[vin[i]] = i ;
        }
        return dfs(pre,  vin,  0, n-1, 0, n-1) ;
    }
    TreeNode *dfs(vector<int>  pre , vector<int> vin , int pl, int pr, int vl ,int vr)
    {
        if(pl > pr)
            return NULL ;
        TreeNode * root = new TreeNode(pre[pl]) ;
        // 左子树的长度为 k 
        int k = pos[pre[pl]] -vl ;
        root->left = dfs(pre ,vin , pl+1 , pl+k ,vl ,vl+k -1) ;
        root->right = dfs(pre ,vin , pl+k +1 , pr ,vl+k+1 ,vr) ;
        return root ;
    }
};
```

### 5：用两个栈实现队列

用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型

```
class Solution
{
public:
    void push(int node) {
        while(!stack2.empty()){
            stack1.push(stack2.top()) ;
            stack2.pop() ;
        }
        stack1.push(node) ;
    }
    int pop() {
        while(!stack1.empty()){
           stack2.push( stack1.top() ) ;
           stack1.pop() ;
        }
        
        int res = stack2.top() ;
        stack2.pop() ;
        return res; 
    }
private:
    stack<int> stack1;
    stack<int> stack2; 
};
```

### 6： 旋转数组的最小数字

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

```
class Solution {
public:
    int minNumberInRotateArray(vector<int> rotateArray) {
        int n = rotateArray.size();
        for(int i = 0 ; i < n-1 ; i++){
            if(rotateArray[i] >rotateArray[i+1])
                return rotateArray[i+1] ;    
        }
        return 0 ; 
    }
};
```

### 7： 斐波拉契数列

```
class Solution {
public:
    int Fibonacci(int n) {
        if(n==0 || n ==1)
            return n ;
        int  a = 0 ;
        int  b =1 ;
        int c ;
         for(int i=2 ;i<n+1 ;i++){
          c = a +b ;
          a = b ;
          b = c ;
        }
        return c;
    }
};
```

### 8：跳台阶

一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

```
class Solution {
public:
    int jumpFloor(int number) {
        if(number==1)
            return 1 ;
        if(number==2)
            return 2 ;
        return jumpFloor(number-1)+jumpFloor(number-2);
    }
};
```

### 9： 变态跳台阶

一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

```
class Solution {
public:
    int jumpFloorII(int number) {
        if(number  ==1 )
            return 1 ;
        int fn = 1 ;
        for(int i =2; i<=number ;i++)
            fn = fn*2 ;
        return fn ;
    }
};
```

### 10： 矩形覆盖

 我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，从同一个方向看总共有多少种不同的方法？ 

   比如n=3时，2*3的矩形块有3种不同的覆盖方法(从同一个方向看)

```
class Solution {
public:
    int rectCover(int number) {
        if(number ==1)
            return 1 ;
        if(number == 2 )
            return 2 ;
        int f1 = 1 ;
        int f2 = 2 ;
        int f3 ;
        for(int i = 1 ;i<= number-2;i++ ){
            f3 = f1 + f2 ;
            f1 = f2 ;
            f2 = f3 ;
        }
            return f3 ;
    }
};
```

### 11： 二进制中1的个数

输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。

```
方法1:除2取模法。
int val; // input data
int ans = 0;
while (val != 0) {
    int tmp = val % 2;
    if (tmp == 1) ++ans;
    val /= 2;
}
方法2:二进制移位法
class Solution {
public:
     int  NumberOf1(int n) {
         int res = 0 ;
         while(n!=0){
            res ++ ;
             n = n & (n-1) ;
         }
         return res ;
     }
};
```

### 12： 数值的整数次方

给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。

保证base和exponent不同时为0。不得使用库函数，同时不需要考虑大数问题，也不用考虑小数点后面0的位数。

```
class Solution {
public:
    double Power(double base, int exponent) {
        double res =1;
        if(base ==0)
            return 0 ;
        int e = exponent >0?exponent : -exponent ;
        for(int i =1 ;i<= e;i++){
            res *= base;
        }
        return exponent>0 ?res : 1/res ;
    }
};
```

### 13： 调整数组顺序使奇数位于偶数前面

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

```
class Solution {
public:
    vector<int> reOrderArray(vector<int>& array) {
        // write code here
        vector<int > res1 ,res2 ;
        int n = array.size() ;
        for(int i =0 ;i< n ;i++){
            if(array[i]%2==0){
                res1.push_back(array[i]);
            }
            else{
                res2.push_back(array[i]) ;
            }
        } 
        for(int i =0 ;i<res1.size() ;i++)
            res2.push_back(res1[i]) ;
        return  res2; 
    }
};
```

### 14： 链表中倒数第k个节点

  输入一个链表，输出该链表中倒数第k个结点。 如果该链表长度小于k，请返回空。 

```
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 *	ListNode(int x) : val(x), next(nullptr) {}
 * };
 */
class Solution {
public:
    ListNode* FindKthToTail(ListNode* pHead, int k) {
        // write code here
        ListNode * fast , *slow  ;
        fast = slow = pHead ;
        while(k--){
            if(fast==NULL)
            return NULL; 
             fast = fast->next ;
        }
        while(fast){
            fast = fast ->next ;
            slow = slow->next ;
        }
        return slow ;
    }
};
```

### 15： 反转链表

输入一个链表，反转链表后，输出新链表的表头

```
way1: 构建链表
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        if (!pHead) return nullptr;
        vector<ListNode*> v;
        while (pHead) {
            v.push_back(pHead);
            pHead = pHead->next;
        }
        reverse(v.begin(), v.end()); // 反转vector，也可以逆向遍历
        ListNode *head = v[0];
        ListNode *cur = head;
        for (int i=1; i<v.size(); ++i) { // 构造链表
            cur->next = v[i]; // 当前节点的下一个指针指向下一个节点
            cur = cur->next; // 当前节点后移
        }
        cur->next = nullptr; // 切记最后一个节点的下一个指针指向nullptr
        return head;
    }
};
wa2: 
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        ListNode *pre = nullptr;
        ListNode *cur = pHead;
        ListNode *nex = nullptr; // 这里可以指向nullptr，循环里面要重新指向
        while (cur) {
            nex = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nex;
        }
        return pre;
    }
};
```

### 16： 合并两个排列的链表

输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

```
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
        ListNode * res  =  new ListNode(0);
        ListNode * head = res ;
        ListNode * p ; 
        while(pHead1 && pHead2){
            if(pHead1->val < pHead2->val){
                 p =new ListNode(pHead1->val );
                res->next = p ;
                res = p ;
                pHead1 = pHead1->next ;
            }
            else{
                p =new ListNode(pHead2->val );
                res->next = p ;
                res = p ;
                pHead2 = pHead2->next ;
            }
        }
        pHead1 = pHead1!=NULL? pHead1:pHead2 ;
        while(pHead1){
              p =new ListNode(pHead1->val );
                res->next = p ;
                res = p ;
                pHead1 = pHead1->next ;
        }
        return head->next ;
    }
};
```

### 17： 树的字结构

输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

```
/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
     bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) {
        if(!pRoot2)return false;
        if(!pRoot1)return false;
        bool root = isSubtree(pRoot1, pRoot2);
        if(root)return true;
        else{
            return HasSubtree(pRoot1->left, pRoot2) || HasSubtree(pRoot1->right, pRoot2);
        }
    }
    bool isSubtree(TreeNode* pRoot1, TreeNode* pRoot2) {
        if(!pRoot2)return true;
        if(!pRoot1)return false;
        if(pRoot1->val == pRoot2->val){
            return isSubtree(pRoot1->left, pRoot2->left)&& isSubtree(pRoot1->right, pRoot2->right);
        }else return false;
         
    }
};
```

### 18： 二叉树的镜像

操作给定的二叉树，将其变换为源二叉树的镜像。

![image-20210529091555985](C:\Users\Mrwang\AppData\Roaming\Typora\typora-user-images\image-20210529091555985.png)

输入：{8,6,10,5,7,9,11}返回值：{8,10,6,11,9,7,5}

```
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 *	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * };
 */
class Solution {
public:
    TreeNode* Mirror(TreeNode* root) {
        // write code here
         if(!root)
             return NULL ;
        stack<TreeNode*> st ;
        st.push(root) ;
        while(!st.empty()){
            TreeNode * tmp = st.top() ;
            st.pop() ;
            // 层次遍历的操作
            TreeNode *left = tmp->left ;
            tmp->left = tmp->right ;
            tmp->right = left ;
            if(tmp->left)
                st.push(tmp->left) ;
            if(tmp->right)
                st.push(tmp->right) ;
        }
        return root  ; 
    }
};

//
//    if(R==NULL)
//             return NULL;
//         Mirror(R->left) ;   // 先序遍历 
//         TreeNode *temp = R->left;
//         R->left = R->right;
//         R->right = temp;
//         Mirror(R->left) ;   // 左子树和右子树已近交换 。 
//         return R ;
```

### 19： 顺时针打印矩阵

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.

```
class Solution {
public:
    vector<int> printMatrix(vector<vector<int> > matrix) {
        // 一定要判断边界条件 
        int rows = matrix.size() ;
        int cols  = matrix[0].size() ;
        vector<int > res ;
        int left= 0 ;
        int right = cols-1 ;
        int low = 0 ;
        int hig = rows -1 ;
         if (rows == 0 || cols == 0)  return res;
        while(left <=right && low <= hig){
            //向右
            for(int i = left ; i <=right ;i++)
                res.push_back(matrix[low][i]) ;
            //向下 
            for(int j =low+1 ;j<= hig ;j++)
                 res.push_back(matrix[j][right]) ;
            // 向左
            if(low <hig ){
                for(int i = right -1 ; i>=left ;i--)
                    res.push_back(matrix[hig][i]);
            }
            // 向上
            if(left<right){
                for(int j=hig -1 ; j>=low +1 ;j--)
                 res.push_back(matrix[j][left]);
            }
            low++ ;
            hig-- ;
            left ++ ;
            right -- ;
        }
  
        return res ;
    }
};
```

### 20： 包含min函数的栈

定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。

```
class Solution {
public:
    public :
    stack<int> s1 ;
    stack<int> s2 ;
    void push(int value) {
        s1.push(value);
        if(s2.empty() || s2.top()>value)
            s2.push(value) ;
    }
    void pop() {
        int tmp = s1.top() ;
        s1.pop() ;
        if(s2.top() == tmp)
            s2.pop() ;
    }
    int top() {
        return s1.top() ;
    }
    int min() {
      return  s2.top();
    }
};
```

### 21： 栈的压入，弹出序列

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

示例1

输入：[1,2,3,4,5],[4,3,5,1,2]

返回值：false

```
class Solution {
public:
    bool IsPopOrder(vector<int> pushV,vector<int> popV) {
        stack<int> tmp ;
        int i = 0 ;
        int j = 0 ;
        for(i = 0 ;i< pushV.size() ; i++){
            tmp.push(pushV[i]) ;
            while(!tmp.empty() && tmp.top() == popV[j]){
                tmp.pop() ;
                j++ ;
            }
        }
       return tmp.empty() ;
     
    }
};
```

### 22： 从上往下打印二叉树

从上往下打印出二叉树的每个节点，同层节点从左至右打印。

```
输入：{5,4,#,3,#,2,#,1}返回值：[5,4,3,2,1]
/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
    vector<int> PrintFromTopToBottom(TreeNode* root) {
            queue<TreeNode *> que ;
            vector<int > res ;
             if(!root)
                 return res ;
            que.push(root);
            while(!que.empty()){
                TreeNode * node = que.front() ;
                 res.push_back(node->val);
                 que.pop() ;
                if(node->left)
                    que.push(node->left);
                 if(node->right)
                    que.push(node->right);
            }
             return res ;    
    }
};

```

### 23： 二叉搜索树的后序遍历

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。（ps：我们约定空树不是二叉搜素树）

```
输入：[4,8,6,12,16,14,10]
返回值：true
class Solution {
public:
    vector<int >seq ;
    bool VerifySquenceOfBST(vector<int> sequence) {
       int n =sequence.size()-1; 
       int begin = 0 ;
        if(sequence.empty())
            return false ;
        while(n){
            while( sequence[begin]< sequence[n])
                begin++ ;
            while(sequence[begin]>sequence[n])
                begin++ ;
            if(begin< n)
                return false ;
            n -- ;
            begin = 0 ;
        }
        return true ;
    }
};

```

### 24： 二叉树中和为某一值得路径

输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径

```
/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
    vector<vector<int >>res ;
        vector<int > path ;
    vector<vector<int> > FindPath(TreeNode* root,int expectNumber) {
        dfs(root,  expectNumber);
        return res ;
        
    }
    void dfs(TreeNode *root , int expectNumber){
        if(!root)
            return ;
        expectNumber -=root->val ;
        path.push_back(root->val) ;
        if(expectNumber==0 && !root->left&&!root->right)
            res.push_back(path) ;
        dfs(root->left,  expectNumber);
        dfs(root->right,  expectNumber);
        path.pop_back() ;
    }
};
```

### 25： 复杂链表的复制

输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）

```
/*
struct RandomListNode {
    int label;
    struct RandomListNode *next, *random;
    RandomListNode(int x) :
            label(x), next(NULL), random(NULL) {
    }
};
*/
class Solution {
public:
    RandomListNode* Clone(RandomListNode* pHead) {
        if(!pHead)
            return NULL ;
        RandomListNode *cur = pHead ;
        // 1 第1步复制 next 
        while(cur){
            RandomListNode *clone = new RandomListNode(cur->label) ;
            clone->next =cur->next ;
            cur->next = clone ;
            cur = clone->next ;
        }
        // 2 ： 第2 步： 复制random
        cur = pHead ;
        while(cur){
            if(cur->random)
                cur->next->random = cur->random->next ; // cur->random 当前节点 -》next当前节点复制的节点
            cur = cur->next->next ;
        }
        RandomListNode  *pre =pHead ;
        cur = pre->next ;
        RandomListNode *res = cur ;
        // 拆开 
        while(cur->next){
            pre->next  = pre->next->next ;
            cur->next = cur->next->next ;
            pre = pre->next ;
            cur = cur->next ;
        }
        pre->next = NULL ;
        return res ;
    }
};
```

### 26： 二叉搜索树与双向链表

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向

```
/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
     TreeNode *pre =NULL ;
    TreeNode* Convert(TreeNode* root) {
        if(root==NULL)
            return NULL ;
        Convert(root->right) ;
        if(pre){
            root->right = pre ;
            pre->left = root ;
        }
        pre =  root ;
        Convert(root->left) ;
        return pre ;
    }   
};
```

### 27： 字符串的排列

输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。

```
class Solution {
public:
    vector<string> res ;
     set<string> tmp ;
    vector<string> Permutation(string str) {
       
        if(str.empty())
            return {}  ;
        perm(0,str) ;
        return vector<string>({tmp.begin() ,tmp.end()});
        
        
    }
    void perm(int pos , string s  ){
        if(pos+1 == s.length()){
             tmp.insert(s) ;
            return ; 
        } 
        // for循环和swap的含义：对于“ABC”，
        // 第一次'A' 与 'A'交换，字符串为"ABC", pos为0， 相当于固定'A'
        // 第二次'A' 与 'B'交换，字符串为"BAC", pos为0， 相当于固定'B'
        // 第三次'A' 与 'C'交换，字符串为"CBA", pos为0， 相当于固定'C
        for(int i = pos ; i<s.length() ;i++){
            swap(s[pos],s[i]) ;
            perm(pos+1, s) ;
            swap(s[pos], s[i]) ;
            // 回溯的原因：比如第二次交换后是"BAC"，需要回溯到"ABC"
            // 然后进行第三次交换，才能得到"CBA"
        }
    }
};
```

### 28： 数组中出现次数超过一半的数字

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。你可以假设数组是非空的，并且给定的数组总是存在多数元素。1<=数组长度<=50000

```
class Solution {
public:
    int MoreThanHalfNum_Solution(vector<int> numbers) {
        unordered_map<int, int > map ;
        int n = numbers.size() ;
        for(int i =0 ;i<n ;i++){
            map[numbers[i]] +=1;
        }
        int res = map[numbers[0]] ;
        int  v = numbers[0] ;
        for(int i = 1 ;i<n ;i++){
            if( map[numbers[i]]> res) {
                 res = map[numbers[i]] ;
                 v = numbers[i];
            }
            
        }
        if(res > n /2)
            return v  ;
        return 0 ; 
    }
};
```

### 29： 最小的k个数

给定一个数组，找出其中最小的K个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。如果K>数组的长度，那么返回一个空的数组

```
输入：[4,5,1,6,2,7,3,8],4 返回值：[1,2,3,4]
class Solution {
public:
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
        vector<int> res ;
        if(k>input.size() || k<=0)
            return res ;
        sort(input.begin(), input.end()) ;
        for(int i = 0 ; i< k ;i++){
             res.push_back(input[i]) ;
        }
        return res ;
    }
};
```

### 30： 连续子数组的最大和

输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n).

```
输入：[1,-2,3,10,-4,7,2,-5] 返回值：18
说明：
输入的数组为{1,-2,3,10,—4,7,2,一5}，和最大的子数组为{3,10,一4,7,2}，因此输出为该子数组的和 18。
class Solution {
public:
    int FindGreatestSumOfSubArray(vector<int> array) {
        int n  = array.size();
        vector<int> dp(n+1 ,0) ;
        int res =array[0] ; 
        for(int i=0 ;i<n ;i++){
            dp[i] =max(array[i] ,dp[i-1]+array[i]) ;
            res = max(dp[i] ,res ) ;
        }
        return res ;
    }
};
```

### 31： 整数中1出现的次数

输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数
 例如，1~13中包含1的数字有1、10、11、12、13因此共出现6次

```
输入：13返回值：6
class Solution {
public:
    int f1(int n ){
        int res = 0 ;
        if(n==1)
            return 1 ;
        while(n){
            int t = n %10 ;
            if(t ==1)
                res ++ ;
            n /=10 ; 
        }
        return res ;
    }
    int NumberOf1Between1AndN_Solution(int n) {
        int sum = 0 ;
        for(int i=1 ;i<=n ;i++){
            sum+=f1(i);
        }
        return  sum ;
    }
};

```

### 32： 把数组排成最小的数

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。

```
输入：[3,32,321]返回值："321323"
# -*- coding:utf-8 -*-
class Solution:
    def PrintMinNumber(self, numbers):
        # write code here
        s=''
        n = len(numbers)
        for i in range(n):
            for j in range(i+1,n):
                s1 = str(numbers[i]) + str(numbers[j])
                s2 = str(numbers[j]) + str(numbers[i])
                s1 = int(s1) 
                s2 = int (s2)
                if s1 > s2 :
                    tmp = numbers[j]
                    numbers[j] = numbers[i]
                    numbers[i] = tmp 
        for item in numbers:
            s += str(item)
        return s 

```

33： 丑数

把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

```
输入：7 返回值：8
class Solution {
public:
    int GetUglyNumber_Solution(int index) {
        vector<int> r(1,1) ;
        if(index < 7)
            return index ;
        int i = 0 ;
        int j = 0 ;
        int k = 0 ; 
     
        while(--index){
            int t =min(5*r[k] , min(2*r[i],3*r[j]) );
               r.push_back(t) ;
             if(t==r[i]*2) i++ ;
              if(t==r[j]*3) j++ ;
              if(t==r[k]*5) k++ ;
            
        }
        return r.back();
    }
};
```

### 34： 第一个只出现一次的字符位置

在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）

```
输入："google" 返回值：4
class Solution {
public:
    int FirstNotRepeatingChar(string str) {
        unordered_map<char, int > mp ;
        for(const char ch : str){
             ++mp[ch] ;
        }
        for(int i = 0 ;i<str.length();i++){
            if(mp[str[i]]==1)
                return i ;
        }
        return -1 ;
    }
};
```

### 35： 数组中的逆序对

  在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。  即输出P%1000000007 

  对于50%50\%50%的数据,size≤104size\leq 10^4size≤104
 对于75%75\%75%的数据,size≤105size\leq 10^5size≤105
 对于100%100\%100%的数据,size≤2∗105size\leq 2*10^5size≤2∗105

```
输入：[1,2,3,4,5,6,7,0] 返回值：7
1: 暴力
class Solution {
private:
    const int kmod = 1000000007;
public:
    int InversePairs(vector<int> data) {
        int ret = 0;
        int n = data.size();
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if (data[i] > data[j]) {
                    ret += 1;
                    ret %= kmod;
                }
            }
        }
 
        return ret;
    }
};
2： 并规排序
class Solution {
private:
    const int kmod = 1000000007;
public:
    int InversePairs(vector<int> data) {
        int ret = 0;
        // 在最外层开辟数组
        vector<int> tmp(data.size());
        merge_sort__(data, tmp, 0, data.size() - 1, ret);
        return ret;
    }

    void merge_sort__(vector<int> &arr, vector<int> &tmp, int l, int r, int &ret) {
        if (l >= r) {
            return;
        }

        int mid = l + ((r - l) >> 1);
        merge_sort__(arr, tmp, l, mid, ret);
        merge_sort__(arr, tmp, mid + 1, r, ret);
        merge__(arr, tmp, l, mid, r, ret);
    }

    void merge__(vector<int> &arr, vector<int> &tmp, int l, int mid, int r, int &ret) {
        int i = l, j = mid + 1, k = 0;

        while (i <= mid && j <= r) {
            if (arr[i] > arr[j]) {
                tmp[k++] = arr[j++];
                ret += (mid - i + 1);
                ret %= kmod;
            }
            else {
                tmp[k++] = arr[i++];
            }
        }

        while (i <= mid) {
            tmp[k++] = arr[i++];
        }
        while (j <= r) {
            tmp[k++] = arr[j++];
        }
        for (k = 0, i = l; i <= r; ++i, ++k) {
            arr[i] = tmp[k];
        }
    }

};
```

### 36：两个链表的第1个公共节点

输入两个无环的单链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）

```
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        ListNode *res ,*tmp ;
        while(pHead1){
            tmp = pHead2 ;
            while(tmp){
                 if(pHead1->val == tmp->val){
                res =  tmp ;
                return res ;
                }
                else tmp = tmp->next ;
            }
            pHead1 = pHead1->next ;  
        }
        return NULL ;
    }
};
```

### 37： 数字在排列数组中出现的次数  二分查找

统计一个数字在升序数组中出现的次数。

```
输入：[1,2,3,3,3,3,4,5],3 返回值：4
class Solution {
public:
    int GetNumberOfK(vector<int> data ,int k) {
        int res = 0 ;
        int n = data.size() ;
        if(0==n)
            return res ;
        int left = 0  ;
        int right = n-1 ;
        while(left<=right){
            int mid = (left + left) /2 ;
            if(data[mid] == k){
                int i = mid-1 ;
                int j = mid +1 ;
                res  =1 ;
                while(data[i]==k){
                     res ++ ;
                    i-- ;
                }
                while(data[j]==k){
                    res ++ ;
                    j++ ;
                }
                return res ;
                
            }
            else if(data[mid]> k){
                right = mid -1 ;
            }
            else{
                left = mid+1 ;
            }
        }
        return res ;
    }
};
```

### 38： 二叉树的深度

输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。

```
输入：{1,2,3,4,5,#,6,#,#,7}返回值：4
/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
    int TreeDepth(TreeNode* pRoot) {
         queue<TreeNode *> que ;
         vector<int> visit ;
        if(!pRoot)
            return 0 ;
          int dep = 0 ;
         que.push(pRoot);
        while(!que.empty()){
            int sz = que.size() ;
            while(sz--){
                TreeNode *node = que.front() ;
                que.pop() ;
              if(node->left)
                que.push(node->left) ;
            if(node->right)
                  que.push(node->right) ;
            }
             dep++ ;
        }   
        return dep ;
    }
};
```

### 39： 平衡二叉树

  输入一棵二叉树，判断该二叉树是否是平衡二叉树。 

  在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树 

  **平衡二叉树**（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

```
输入：{1,2,3,4,5,6,7}返回值：true
class Solution {
public:
    bool IsBalanced_Solution(TreeNode* pRoot) {
        if(!pRoot)
            return true ;
        int res = depth(pRoot) ;
        
        return res !=-1;
        
    }
    int  depth(TreeNode * root){
        if(root==NULL )
            return 0 ;
        int left = depth(root->left) ;
        if(left == -1)
            return -1 ;
        int right = depth(root->right) ;
        if(right==-1)
            return -1 ;
        if( abs(left -right)>1)
            return -1 ;
        return 1+(left >right ?left :right) ;
    }
    
};
```

### 40： 数组中只出现一次的数字

一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

```
输入：[1,4,1,6]返回值：[4,6]说明：返回的结果中较小的数排在前面 
class Solution {
public:
    vector<int> FindNumsAppearOnce(vector<int>& array) {
        // write code here
        vector<int> res ;
        int n = array.size() ;
        vector<int>map(n,1) ;
        for(int i = 0 ;i <n ; i++){
            int flag = 1 ;
            if(map[i]==0)
                continue ;
            for(int j= i+1 ;j<n ;j++){
                if(array[i]==array[j]){
                    flag = 0 ;
                    map[j] = 0 ;
                    break ;
                }
            }
            if(flag  ==1 )
                res.push_back(array[i]) ;
        }
        return res ;
    }
};
```

### 41： 和为S的连续正数序列

小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!

```
输入：9 返回值： [[2,3,4],[4,5]]
class Solution {
public:
    vector<vector<int> > FindContinuousSequence(int sum) {
        vector<vector<int> >  res  ;
        int i , j ;
        for( i = 1 ;i< sum-1 ;i++){
            int temp  = sum ;
             j = i ;
            while(temp>0){
                temp -=j ;
                if(temp == 0){
                    vector<int> r ;
                    for(int k =i ;k<=j ; k++)
                        r.push_back(k) ;
                    res.push_back(r) ;
                    break ;
                }
                 j++ ;
            }
            
        }
       return res ; 
    }
};
```

### 42： 和为S的两个数字

输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。

```
输入：[1,2,4,7,11,15],15返回值：[4,11]
class Solution {
public:
    vector<int> FindNumbersWithSum(vector<int> array,int sum) {
        int n = array.size();
        vector<int>res(2,0) ;
        int mul = 999999;
        for(int i = 0 ;i < n ;i++){
            for(int j= i+1 ; j< n ;j++){
                if(sum ==array[i]+array[j]){
                    if(array[i]*array[j]<mul){
                        mul = array[i]*array[j] ;
                        res[0] = array[i] ;
                        res[1] =array[j] ;
                     }
                }
            }
        }
        if(res[0]==0){
            res.pop_back() ;
            res.pop_back() ;
             return res ;
        }     
        return res ;  
    }
};

```

### 43：左旋转字符串

汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！

```
输入："abcXYZdef",3返回值："XYZdefabc"
class Solution {
public:
    string LeftRotateString(string str, int n) {
        if(str.size() == 0)
            return "" ;
        reverse(str.begin(),str.end()) ;
        reverse(str.begin(), str.end()  - n) ;
        reverse(str.end() - n, str.end()) ;
        return str ;
    }
};
```

### 44：翻转单词序列

牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“nowcoder. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a  nowcoder.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？

```
输入："nowcoder. a am I"返回值："I am a nowcoder."
class Solution {
public:
    string ReverseSentence(string str) {
        string res ;
        string temp ;
        for(auto c : str){
            if(c ==' '){
                res  =temp + ' ' + res ;
                temp  ="" ;
            }
            else{
                temp +=c ;
            }
        }
        res = temp + ' '+res ;
        res = res.substr(0,res.size() -1) ;
        return res ;
    }
};
```

### 45：派克牌顺子

现在有2副扑克牌，从扑克牌中随机五张扑克牌，我们需要来判断一下是不是顺子。
 有如下规则：

1. A为1，J为11，Q为12，K为13，
2. A不能视为14大、小王为 
3. 0，0可以看作任意牌

如果给出的五张牌能组成顺子（即这五张牌是连续的）就输出true，否则就输出false。
 例如：给出数据[6,0,2,0,4]
 中间的两个0一个看作3，一个看作5 。即：[6,3,2,5,4]
 这样这五张牌在[2,6]区间连续，输出true
 数据保证每组5个数字，每组最多含有4个零，数组的数取值为 [0, 13]

```
输入：[6,0,2,0,4]返回值：true
#include<algorithm>
class Solution {
public:
    bool IsContinuous( vector<int> numbers ) {
      
      if(numbers.empty())
          return false ;
       sort(numbers.begin() ,numbers.end()) ;
       int i = 0 ;
       int n = numbers.size() ;
        for(int j = 0 ; j<n ;j++){
            if(numbers[j] == 0){
                 i++ ;
                continue ;
            }
            if(j+1 <n && numbers[j]==numbers[j+1])
                return false ;
        }
        return numbers.back() - numbers[i] <5 ;
    }
};

```

### 46：孩子们的游戏（圆圈中最后剩下的数）

每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 

```
输入：5,3返回值：3
class Solution {
public:
    int LastRemaining_Solution(int n, int m) {
          if(n==0)
              return -1 ;
         if(n==1)
             return 0 ;
        else 
            return (LastRemaining_Solution(n-1, m)+m)%n ;
    }
};
```

### 47：求1+2+3+....+n

求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

```
class Solution {
public:
    int Sum_Solution(int n) {
        return n*(n+1) / 2;
    }
};
```

### 48：不用加减乘除做加法

写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。

![image-20210529095301031](C:\Users\Mrwang\AppData\Roaming\Typora\typora-user-images\image-20210529095301031.png)

```
class Solution {
public:
    int Add(int num1, int num2) {
       while(num2!=0){
           int c = ((unsigned)(num1 &num2) )<<1 ;
           num1 ^= num2 ;
           num2 = c; 
       }
        return num1 ;
    }
};
```

### 49：把字符串转换成整数

将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。        数值为0或者字符串不是一个合法的数值则返回0

```
输入："+2147483647"返回值：2147483647
class Solution {
public:
    int StrToInt(string str) {
        int  res ;
        string temp ;
        int n  =str.size() ;
        int i = 0 ;
        char mark ;
        if(str[0]<='9' && str[0]>='0')
            i =1 ;
        for(auto c :str){
            if(i==0){
             i++ ;
             mark = c ;
               continue ; 
            }
            if(c<='9'&&c >='0'){
                temp +=c;
            }
            else{
                return 0 ;
            }
        }
       res = atoi(temp.c_str());
        if(mark =='-')
            res = -res ;
        return res ;
    }
};
```

### 50：数组中重复的数字

在一个长度为n的数组里的所有数字都在0到n-1的范围内。  数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任一一个重复的数字。  例如，如果输入长度为7的数组[2,3,1,0,2,5,3]，那么对应的输出是2或者3。存在不合法的输入的话输出-1

```
输入：[2,3,1,0,2,5,3]返回值：2
说明：2或3都是对的 
class Solution {
public:
      替换法：
      数组按照顺序 [a1 ,a2 ,a3, ... an]
      每个位置a[i]  = i  ,  否则就替换 a[i] = a[a[i]] 
       C++ 
       set: 不重复数组
       map:   k-v ++ 当 >1 返回数字
    
    */
    int duplicate(vector<int>& numbers) {
        // write code here
        int n = numbers.size() ;
        for(int i = 0 ;i< n ;i++){
            while(numbers[i]!=i){
                if(numbers[i] == numbers[numbers[i]])
                    return numbers[i];
                 else 
                     swap(numbers[i],numbers[numbers[i]]) ;
            }
        }
        return -1 ;
    }
};
```

### 51： 构建乘积数组

   给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * ... * A[n-1]，B[n-1] = A[0] * A[1] * ... * A[n-2];） 

```
输入：[1,2,3,4,5]返回值：[120,60,40,30,24]
class Solution {
public:
    vector<int> multiply(const vector<int>& A) {
        vector<int> res ;
        int n = A.size() ;
        if(n<=1)
            return res ;
        for(int i = 0 ; i< n ;i++){
             int temp =1 ;
            for(int j = 0 ;j<n ;j++){
                if(i!=j){
                    temp *=A[j] ;
                }
            }
            res.push_back(temp) ;
        }
        return res ;
    }
};
```

### 52： 正则表达式

请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（包含0次）。  在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但是与"aa.a"和"ab*a"均不匹配

```
输入："aaa","a*a"返回值：true
class Solution {
public:
    bool match(string str, string pattern) {
        // write code here
        int n = str.size() ;
        int m = pattern.size() ;
        vector<vector<bool> > dp(n+1 ,vector<bool>(m+1));
        dp[0][0] = true ;
        for(int i =1 ;i<m+1;i++){
            if(pattern[i-1]=='*')
                dp[0][i] = dp[0][i-2] ;
        }
        for(int i = 1 ;i< n+1;i++){
            for(int j =1 ;j< m+1 ;j++){
              
                 if(pattern[j-1]=='*'){
                     if(str[i-1] == pattern[j-2] || pattern[j-2]=='.')
                           dp[i][j] =dp[i-1][j] || dp[i][j-2];
                    else 
                        dp[i][j] =dp[i][j-2] ;
                }
            }
            return dp[m][n] ;
        }
    }
};
```

### 53： 表示数值的字符串

请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。

```
/*
   参考剑指offer,改动了一些小部分。
    数值可以表示为 A[.[B]]e|E[C]
    其中A 和C 可以带有正负号，B不能带有符号
    A可以没有，B也可以没有，不过在'.'的情况下
    在e|E ，B是必须有的，所以这就是在判断str[index]=='.' 和str[index]=='e'||             
    str[index]=='E'时是使用不同运算符的原因。
    然后分解成两个函数小函数我觉得可读性强一点，毕竟代码给人看的，想看细节的同学
    请移步剑指offer官方书籍。
*/
class Solution {
public:
   
    bool isNumeric(string str) {
        // write code here
        if(str.empty()) return false;
        size_t index=0;
        bool numeric=scanInteger(str,index);
        if(str[index]=='.'){
            ++index;
            bool hasNumbers=scanUnsignedInteger(str,index);
            numeric=hasNumbers || numeric;
        }
        if(str[index]=='e'|| str[index]=='E'){
            ++index;
            numeric=numeric && scanInteger(str,index);
        }
        return numeric && (index==str.size());

    }
    bool scanInteger(string& str,size_t& index){
        if(str[index]=='+'||str[index]=='-')
            ++index;
        return scanUnsignedInteger(str,index);
    }
    bool scanUnsignedInteger(string& str,size_t& index){
        size_t begin=index;
        while(str[index]!='\0' && str[index]>='0'&& str[index]<='9')
            ++index;
        return index>begin;
    }
};
```

### 54： 字符流中第一个不重复的字符

  请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。 

  后台会用以下方式调用Insert 和 FirstAppearingOnce 函数  

```
class Solution
{
public:
  //Insert one char from stringstream
      queue<char> que ;
      unordered_map<char, int > mp ;
    void Insert(char ch) {
        if(mp.find((ch))==mp.end()){
            que.push(ch) ;
        }
        mp[ch]++ ;
        
    }
  //return the first appearence once char in current stringstream
    char FirstAppearingOnce() {
        while(!que.empty()){
            char ch = que.front() ;
            if(mp[ch]==1)
                return ch ;
            else 
                que.pop() ;
        }
        return '#' ;
    }
};
```

### 55： 链表中环的入口位置

给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null

```
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
        val(x), next(NULL) {
    }
};
*/
class Solution {
public:
    ListNode* EntryNodeOfLoop(ListNode* pHead) {
        ListNode *fast = pHead;
        ListNode *slow  = pHead;
        while(fast && fast->next ){
            fast = fast->next->next ;
            slow = slow->next ;
            if(fast == slow ){
               ListNode * slow2 = pHead ;
                while(slow2!=slow){
                    slow2 = slow2->next ;
                    slow = slow->next ;
                    
                }
                return slow2 ;
            }
        }
        return NULL ;
      }

};
```

### 56： 删除链表中重复的节点

在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5

```
输入：{1,2,3,3,4,4,5}返回值：{1,2,5}
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
        val(x), next(NULL) {
    }
};
*/
class Solution {
public:
    ListNode* deleteDuplication(ListNode* pHead) {
        ListNode *head = new ListNode(0) ;
        head->next = pHead ;
        ListNode *pre = head ;
        ListNode *cur = pHead ;
        while(cur){
             if(cur->next && cur->val == cur->next->val){
                  cur =cur->next ;
                 while(cur->next && cur->val == cur->next->val){
                     cur = cur->next; 
                 }
                 cur = cur->next ;
                 pre->next = cur ;
             }
            else{
                pre = cur ;
                cur = cur->next ;
            }
        }
        return head->next ;
    }
};

```

### 57： 二叉树的下一个节点

给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的next指针

```
/*
struct TreeLinkNode {
    int val;
    struct TreeLinkNode *left;
    struct TreeLinkNode *right;
    struct TreeLinkNode *next;
    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) {
    }
};
*/
class Solution {
public:
    TreeLinkNode* GetNext(TreeLinkNode* pNode) {
        if(!pNode)
            return pNode ;
        if(pNode->right){
            pNode = pNode->right ;
            while(pNode->left)
                pNode = pNode->left ;
            return pNode ;
        }
        while(pNode->next){
            TreeLinkNode *root = pNode->next ;
            if(root->left ==pNode)
                return root ;
            pNode = pNode->next ;
        }
  return nullptr ; 
    }
};
```

### 58： 对称二叉树

实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。

```
输入：{8,6,6,5,7,7,5}返回值：true
class Solution {
public:
    bool isSame(TreeNode *root1, TreeNode *root2) {
        if (!root1 && !root2) return true;
        if (!root1 || !root2) return false;
        return root1->val == root2->val && 
        isSame(root1->left, root2->right) &&
        isSame(root1->right, root2->left);
    }
    bool isSymmetrical(TreeNode* pRoot)
    {
        return isSame(pRoot, pRoot);
    }
};
```

### 59：按之字型打印二叉树

请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推

```
输入：{8,6,10,5,7,9,11} 返回值：[[8],[10,6],[5,7,9,11]]
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
*/
class Solution {
public:
    vector<vector<int> > Print(TreeNode* pRoot) {
        vector<vector<int> > res ;
        if(!pRoot)
            return res;
        queue<TreeNode *> que ;
        que.push(pRoot) ;
        int level = 1 ;
        while(!que.empty()){
            int sz= que.size() ;
            vector<int> tmp ;
            while(sz--){
                TreeNode * node  = que.front() ;
                que.pop() ;
                 tmp.push_back(node->val) ;
            if(node->left) 
                que.push(node->left) ;
            if(node->right)
                que.push(node->right) ;
            }
            ++level ;
            if(level%2==1)
                reverse(tmp.begin(),tmp.end()) ;
            res.push_back(tmp) ;

        }
        return res ;  
    } 
};
```

### 60： 把二叉树打印成多行

从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。

```
输入：{8,6,10,5,7,9,11}返回值：[[8],[6,10],[5,7,9,11]]
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
*/
class Solution {
public:
        vector<vector<int> > Print(TreeNode* pRoot) {
            vector<vector<int> >res ;
            if(!pRoot)
                return res ;
            queue<TreeNode *> que ;
            que.push(pRoot) ;
            while(!que.empty()){
                int sz =que.size() ;
                vector<int> tmp ;
                while(sz--){
                     TreeNode *node = que.front() ;
                      que.pop() ;
                    tmp.push_back(node->val) ;
                    if(node->left)
                        que.push(node->left) ;
                    if(node->right)
                        que.push(node->right) ;
                }
                res.push_back(tmp) ;
            }
            return res ;
        }
};
```

### 61： 序列化二叉树

  请实现两个函数，分别用来序列化和反序列化二叉树 
 二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。

 例如，我们可以把一个只有根节点为1的二叉树序列化为"1,"，然后通过自己的函数来解析回这个二叉树 

```
输入：{8,6,10,5,7,9,11}返回值：{8,6,10,5,7,9,11}
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
*/
class Solution {
public:
    char* Serialize(TreeNode *root) {    
        if(!root)
            return "#" ;
        string  res = to_string(root->val) ;
        res.push_back(',') ;
        char *left = Serialize(root->left) ;
        char * right = Serialize(root->right) ;
        char *tmp = new char[strlen(left)+strlen(right)+res.size()] ;
        strcpy(tmp, res.c_str()) ;
        strcat(tmp,left ) ;
        strcat(tmp, right) ;
        return tmp ;
      }
    TreeNode *decode(char *&str){
        if(*str=='#'){
            str++ ;
            return nullptr ;
        }
        int num = 0 ;
        while(*str!=','){
            num = num *10 +(*str-'0') ;
            str++ ;
        }
        str++ ;
        TreeNode *root = new TreeNode(num) ;
        root->left = decode(str) ;
        root->right = decode(str) ;
        return root ;
    }
    TreeNode* Deserialize(char *str) {
         return decode(str) ;
    }
};

```

### 62： 二叉搜索树的第k个节点

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。

给定一棵二叉搜索树，请找出其中的第k小的TreeNode结点。

```
输入：{5,3,7,2,4,6,8},3返回值：{4}
说明：
按结点数值大小顺序第三小结点的值为4  
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
*/
class Solution {
public:
    int m  ;
    TreeNode *res ;
    void dfs(TreeNode *node){
        if(!node || m<1)
            return ;
        dfs(node->left) ;
        if(m==1)
            res =node  ;
        if(--m>0)
            dfs(node->right) ;
    }
    TreeNode* KthNode(TreeNode* pRoot, int k) {
        res = NULL ;
        m = k;
        dfs(pRoot) ;
        return res ;
    }
};
```

### 63： 数据流中的中位数

```
暴力方法
class Solution {
public:
    #define SCD static_cast<double>
    vector<int> v;
    void Insert(int num)
    {
        v.push_back(num);

    }
    double GetMedian()
    { 
        sort(v.begin(), v.end());
        int sz = v.size();
        if (sz & 1) {
            return SCD(v[sz >> 1]);
        }
        else {
            return SCD(v[sz >> 1] + v[(sz - 1) >> 1]) / 2;
        }
    }

};
插入排序
class Solution {
public:
    #define SCD static_cast<double>
    vector<int> v;
    void Insert(int num)
    {
        if (v.empty()) {
            v.push_back(num);
        }
        else {
            auto it = lower_bound(v.begin(), v.end(), num);
            v.insert(it, num);
        }
    }

    double GetMedian()
    { 
        int sz = v.size();
        if (sz & 1) {
            return SCD(v[sz >> 1]);
        }
        else {
            return SCD(v[sz >> 1] + v[(sz - 1) >> 1]) / 2;
        }
    }

};
方法三：堆
class Solution {
public:
    #define SCD static_cast<double>
    priority_queue<int> min_q; // 大顶推
    priority_queue<int, vector<int>, greater<int>> max_q; // 小顶堆

    void Insert(int num)
    {

        min_q.push(num); // 试图加入到大顶推

        // 平衡一个两个堆
        max_q.push(min_q.top()); 
        min_q.pop();

        if (min_q.size() < max_q.si***_q.push(max_q.top());
            max_q.pop();
        }

    }

    double GetMedian()
    { 
        return min_q.size() > max_q.size() ? SCD(min_q.top()) : SCD(min_q.top() + max_q.top()) / 2;
    }

};
```

### 64： 滑动窗口最大值

给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个：      {[2,3,4],2,6,2,5,1}，  {2,[3,4,2],6,2,5,1}，      {2,3,[4,2,6],2,5,1}，      {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}，      {2,3,4,2,6,[2,5,1]}。 

```
输入：[2,3,4,2,6,2,5,1],3  返回值：[4,4,6,6,6,5]
暴力
class Solution {
public:
    vector<int> maxInWindows(const vector<int>& num, unsigned int size)
    {
        vector<int> ret;
        if (num.size() == 0 || size < 1 || num.size() < size) return ret;
        int n = num.size();

        for (int i = 0; i + size - 1 < n; ++i) {
            int j = i + size - 1;
            int max_val = num[j];
            for (int k = i; k < j; ++k) {
                max_val = max(max_val, num[k]);
            }
            ret.push_back(max_val);
        }
        return ret;
    }
};
单调队列
class Solution {
public:
    vector<int> maxInWindows(const vector<int>& num, unsigned int size)
    {
        vector<int> ret;
        if (num.size() == 0 || size < 1 || num.size() < size) return ret;
        int n = num.size();
           deque<int> dq;
           for (int i = 0; i < n; ++i) {
               while (!dq.empty() && num[dq.back()] < num[i]) {
                   dq.pop_back();
               }
               dq.push_back(i);
               // 判断队列的头部的下标是否过期
               if (dq.front() + size <= i) {
                   dq.pop_front();
            }
            // 判断是否形成了窗口
               if (i + 1 >= size) {
                   ret.push_back(num[dq.front()]);
               }
           }
           return ret; 
    }
};

```

### 65：矩阵中的路径

![image-20210529101733947](C:\Users\Mrwang\AppData\Roaming\Typora\typora-user-images\image-20210529101733947.png)

```
出口：
当word 下标走到数组大小，代表找到word
当x,y 超出边界，或该数被访问，或matrix位置字符不与word的位置上的相同 都结束返回false。
if(index == word.size()) return true;
if(x < 0 || x >= matrix.size() || y < 0 || y >= matrix[0].size() || visited[x][y] || word[w_index] != matrix[x][y]) return false;

操作：
visited[x][y] = true;
w_index++;
递归：
dfs(matrix, x + dirt[i], y + dirt[i+1], w_index, word, visited);
回溯：
visited[x][y] = false; 

class Solution {
public:
  vector<int> dirt = {1, 0, -1, 0, 1}; // 定义的方向数组
  bool hasPath(vector<vector<char> >& matrix, string word) {
      vector<vector<bool> > visited(matrix.size(),vector<bool>(matrix[0].size(),0));  //定义与matrix 同样大小的 访问数组

      for(int i = 0; i < matrix.size(); i++){
          for(int j = 0; j < matrix[0].size(); j++){
               if(dfs(matrix, i, j, 0, word, visited))return true;  // 必须对每一个数进行dfs搜索，找到直接返回true
          }
      }
     return false; // 否则返回 false
  }

  bool dfs(vector<vector<char> >& matrix, int x, int y, int w_index, string word, vector<vector<bool> >& visited){
      if(w_index == word.size()) return true; // 当word 下标走到数组大小，代表找到word
// 当x,y 超出边界，或该数被访问，或matrix位置字符不与word的位置上的相同 都结束返回false。
      if(x < 0 || x >= matrix.size() || y < 0 || y >= matrix[0].size() || visited[x][y] ||word[w_index] != matrix[x][y]) return false;
      w_index++; // 该点符合要求 ，word下标后移 标记访问
      visited[x][y] = true;
      bool isExist = false;
      for(int i = 0; i < 4; i++){ // 四个方向递归 且结果||
          isExist = isExist || dfs(matrix, x + dirt[i], y + dirt[i+1], w_index, word, visited);
      }

      visited[x][y] = false; // 有& 是引用 递归结束后需要回溯。

      return isExist; // 返回结果
  }
};
```

### 66：机器人的运动范围

地上有一个rows行和cols列的方格。坐标从 [0,0] 到 [rows-1,cols-1]。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于threshold的格子。 例如，当threshold为18时，机器人能够进入方格[35,37]，因为3+5+3+7 = 18。但是，它不能进入方格[35,38]，因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 

```
class Solution {
public:
    struct node{
        int x ;
        int y ;
    }  ;
     int dir[5] = {-1, 0, 1, 0, -1};
    int check(int n) {
        int sum = 0;
        while (n) {
            sum += (n % 10);
            n /= 10;
        }
        return sum;
    }
    int movingCount(int threshold, int rows, int cols) {
        if(threshold<=0)
            return 0 ;
        int value = 0 ;
        int maps[rows][cols] ;
        memset(maps, -1, sizeof(maps)) ;
        queue<struct node> que ;
        que.push({0,0}) ;
         maps[0][0] = 1 ;
        while(!que.empty()){
             auto node = que.front() ;
            que.pop() ;
            ++ value ;
            for(int i = 0 ;i<4 ;i++){
                int x = node.x +dir[i];
                int y = node.y +dir[i+1];
                if(x>=0 && x<rows && y>=0 && y<cols && maps[x][y]==-1){
                    if(check(x)+check(y)<=threshold){
                        que.push({x ,y}) ;
                        maps[x][y] =1 ;
                    }
                }
            }
        }
         return value ;
    }
};

```

### 67 减绳子

给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n>1并且m>1，m<=n），每段绳子的长度记为k[1],...,k[m]。请问k[1]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

```
输入：8返回值：18
class Solution {
public:
    int cutRope(int number) {
        if(number ==2)
            return 1 ;
        if(number ==3)
            return 2 ;
        vector<int> dp(number+1 ,-1) ;
        for(int i =1 ; i<=4 ;i++)
                 dp[i] = i ;
        for(int i =5 ;i<=number ;i++){
            for(int j=1 ;j< i ;j++){
                dp[i] = max(dp[i],j*dp[i-j]) ;
            }
        }
        return dp[number] ;
    }
};
```

### 各种排序

```
#include<iostream>
using namespace std ;
#include<stdlib.h>
#include<time.h>
typedef int datetype ;  // 数据类型
/*****************************************************************************/
            /*  经典排序算法 */
int   insert_sort1( datetype  *Arr,int n ) ;             /*  插入排序  */
void  insert_sort2( datetype *Arr, int n ) ;             /*  插入排序  */
void  select_sort1( datetype *Arr, int n) ;             /*  选择排序  */
void  select_sort2( datetype *Arr,int n ) ;             /*  选择排序2 */
void  Bubblesort(datetype *base ,int n) ;                /*  冒泡排序  */
void Merger_sort(datetype *Arry,int left ,int right)  ;  /*  递归排序  */
int fold_find(datetype *Arr,int low ,int high,int date); /*  折半查找  */
void  quick_sort(datetype *base,int len) ;               /*   快速排序  */
 
 
/*****************************************************************************/
 /* 
            插入排序 （从小到大）
    思想：    Arr[ 0 -n ]
         1）： 从数组第二个位置Arr[i]开始： 与前面元素比较，如果比前一个元素大 ，结束 。   i++ ，继续 1） 否则进入2）
         2) :   数组元素依次后移 a[i++]=aa[i] , 直到 遇到比它小的元素结束 。 然后 到1) ,直到 i =n结束 
  
 */
int insert_sort1(datetype  *base,int n)
{
  int i, j;
  datetype flag ;         // 标志位
  for(i=1;i<n;i++)
  {
     flag=base[i];     
     j=i-1;
     while(flag<base[j]&&j>=0)    //   j>=0 这个条件一定要加上， 这个bug ，我查了很久才发现
     {
       base[j+1]=base[j];
       j--;
     }
     base[j+1]=flag;
  }
}
 
/*   
        插入排序 (优化 ：减少元素位置移动)
*/
 
void  insert_sort2( datetype *Arr, int n)  
{
   int i,j;
   for(i=1;i<n;i++)
   {
     int flag=Arr[i] ;  
	 int pos=0;     
     while(flag>Arr[pos])       // 减少向前搜索 ，主要是数组的移动 。 确定要移动多少位置 
        pos++;
     for(j=i;j>pos;j--)
     {
        Arr[j]=Arr[j-1];
     }
        Arr[pos]=flag ;
   }
}
/*  
    选择排序 :
        思想：   
            每次排序确定一个元素的位置
*/
void  select_sort1( datetype *card, int n)     
{
  int i,j ;
  for(i=0;i<n;i++)
  {
    for(j=i+1;j<n;j++)
    {
       if(card[j]<card[i])
       {
         int t ;
         t=card[j];
         card[j]=card[i];
         card[i]=t;
       }
    }
  }
}
/*  
        选择排序2（改进）
*/
void  select_sort2(datetype *card,int n)  
{
   int i,j ,k；
   datetypet t;
   for(i=0;i<n-1;i++)
   {
       k=i;
       for(j=i+1;j<n;j++)
        if(card[j]<card[i])
            k=j;
        if(k!=i)
        {
          t=card[k];
          card[k]=card[i];
          card[i]=t;
        }
   }
}
/*
    递归排序 :
    思想： 
    1）将数组分成相同两段， Arr1[] ,Arr2[] ,然后 两个数组进行比较， 每比较依次，选出最小的保存到temp []  , 直到一个数组结束，然后把另一个
    数组剩下的元素，直接添加到 temp[] 后。
     2） 对 Arr1 []  Arr2[] 依次进行 1  。
*/
void Merger_sort(datetype *Arry,int left ,int right)                  
{
   if(left==right-1)
    return ;
   int mid=(left+right)/2 ;
   Mergersort(Arry,left,mid);                                     // 递归排序 
   Mergersort(Arry,mid,right);
   int *temp=new int[right-left];                                  //开辟临时数组
   int left_idx=left;
   int right_idx=mid ;
   int  i=0;
   while(left_idx<mid&&right_idx<right)                            //合并 ，依次比较大小 ， 选择 小的
   {
     if(Arry[left_idx]<Arry[right_idx])
        temp[i++]=Arry[left_idx++];
     else 
	 	temp[i++]=Arry[right_idx++];
   }
   while(left_idx<mid)                                   // 数组剩下的元素直接添加到temp [] 后
    temp[i++]=Arry[left_idx++];
   while (right_idx<right)
   temp[i++]=Arry[right_idx++];
   for(int i= 0,idx=left;i<right-left;i++,idx++)
   Arry[idx]=temp[i];
   delete []temp ;
}
 
int fold_find(datetype *Arr,int low ,int high,int date)       /*折半查找 */
{
   int id=-1;
  while(low<=high)
   {
     int middle=(low + high)/ 2 ;
    if(Arr[middle]==date)
    {
        id=middle ;
       return id +1;
    }
       else if(Arr[middle]>date)
    {
       high=middle -1 ;
   }
     else low=middle + 1 ;
   }
 
}
 /*   快速排序  */
void quick_sort(datetype *base,int len)  
 {
    if(len<=1)                     /*  递归终止条件 */
    return ;
    int left_id=0,right_id=0;
    srand((unsigned)time(0));					 //	为rand( )函数初始化随机发生器的启动状态，以产生伪随机数
    int rand_num;
    rand_num=rand()%len ;                        /* 随机选择一个数组作为比较元素 */
    int key = base[rand_num];                   /*关键性元素 ，可以从数组中任意选择 */
    int *left ,*right;
    left = new int [len];
    right =  new int [len];
    for(int i=0;i<len;i++)                      /*拆分 */
    {
       if(base[i]<key)
        left[left_id++]=base[i];
      if(base[i]>key)
      right[right_id++]=base[i];
    }
    quick_sort(left,left_id);                /*1递归  */
    quick_sort(right,right_id);
    int id = 0;
    for(int i=0;i<left_id;i++)
        base[id++]=left[i];
    base[id++]=key ;
    for(int i=0;i<right_id;i++)
       base[id++]=right[i];
    delete [] left ;
    delete [] right ;
 
 
 }
 void Bubblesort(datetype *base ,int n)  /*冒泡排序 */
 {
   int i, j;
   for(i=0;i<n;i++)
   {
     for(j=0;j<n-i;j++)
     {
       if(base[j]>base[j+1])
       {
         int t ;
         t= base [j];
         base[j]=base[j+1];
         base[j+1]=t ;
       }
     }
   }
 }
 
 
 
```

